import ProductVariant from "../models/productVariant.js";
import { GoogleGenerativeAI } from "@google/generative-ai";

// Initialize AI models
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const embeddingModel = genAI.getGenerativeModel({
  model: "text-embedding-004",
});
const chatModel = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

// Configuration constants
const CONFIG = {
  SIMILARITY_THRESHOLD: 0.25, // Gi·∫£m threshold ƒë·ªÉ d·ªÖ t√¨m h∆°n
  MAX_RESULTS: 5,
  EMBEDDING_BATCH_SIZE: 10,
  TEXT_SEARCH_WEIGHT: 0.7, // ∆Øu ti√™n text search
  SEMANTIC_SEARCH_WEIGHT: 0.3,
};

// T·ª´ kh√≥a th√¥ng d·ª•ng cho th·ªùi trang
const FASHION_KEYWORDS = {
  // D√≤ng s·∫£n ph·∫©m
  nam: ["men", "nam", "nam gi·ªõi"],
  n·ªØ: ["ladies", "n·ªØ", "ph·ª• n·ªØ", "women"],
  unisex: ["you", "unisex", "nam n·ªØ"],

  // Nh√≥m s·∫£n ph·∫©m
  √°o: ["√°o", "shirt", "top", "blouse"],
  qu·∫ßn: ["qu·∫ßn", "pants", "trousers", "jean"],
  "√°o kho√°c": ["√°o kho√°c", "jacket", "coat", "blazer"],
  v√°y: ["v√°y", "zu√Ωp", "dress", "skirt"],

  // C·ªï √°o
  "c·ªï tr√≤n": ["c·ªï tr√≤n", "round neck", "crew neck"],
  "c·ªï v": ["c·ªï v", "c·ªï ch·ªØ v", "v neck"],
  "c·ªï ƒë·ª©c": ["c·ªï ƒë·ª©c", "polo", "collar"],

  // Tay √°o
  "tay ng·∫Øn": ["tay ng·∫Øn", "tay c·ªôc", "short sleeve"],
  "tay d√†i": ["tay d√†i", "long sleeve"],
  "s√°t n√°ch": ["s√°t n√°ch", "tank top", "sleeveless"],

  // Ch·∫•t li·ªáu
  cotton: ["thun", "cotton", "co t√¥"],
  jean: ["jean", "denim"],
  l·ª•a: ["l·ª•a", "silk"],
  khaki: ["khaki", "v·∫£i khaki"],

  // M√†u s·∫Øc c∆° b·∫£n
  ƒëen: ["ƒëen", "black"],
  tr·∫Øng: ["tr·∫Øng", "white"],
  xanh: ["xanh", "blue"],
  ƒë·ªè: ["ƒë·ªè", "red"],
  v√†ng: ["v√†ng", "yellow"],
  h·ªìng: ["h·ªìng", "pink"],
};

// Helper function ƒë·ªÉ x·ª≠ l√Ω t·ª´ kh√≥a th√¥ng d·ª•ng
function expandSearchQuery(query) {
  const lowerQuery = query.toLowerCase().trim();
  const expandedTerms = [lowerQuery];

  // M·ªü r·ªông t·ª´ kh√≥a d·ª±a tr√™n FASHION_KEYWORDS
  Object.entries(FASHION_KEYWORDS).forEach(([key, synonyms]) => {
    if (synonyms.some((synonym) => lowerQuery.includes(synonym))) {
      expandedTerms.push(...synonyms);
    }
  });

  return [...new Set(expandedTerms)]; // Lo·∫°i b·ªè tr√πng l·∫∑p
}

// C·∫•u h√¨nh AI search suggestions
export const searchSuggestions = async (req, res) => {
  try {
    const { query } = req.body;

    if (!query || query.trim().length < 2) {
      return res.json({
        success: true,
        suggestions: [],
        message: "Query qu√° ng·∫Øn",
      });
    }

    const searchQuery = query.trim().toLowerCase();
    const expandedQueries = expandSearchQuery(searchQuery);
    console.log("üîç Searching for:", searchQuery);
    console.log("üìù Expanded queries:", expandedQueries);

    // T·∫°o regex pattern cho t·∫•t c·∫£ t·ª´ kh√≥a m·ªü r·ªông
    const regexPattern = expandedQueries
      .map(
        (term) => term.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") // Escape special regex chars
      )
      .join("|");

    // 1. Text search v·ªõi aggregate ƒë·ªÉ c√≥ th·ªÉ search nested fields v√† attributes
    const textSearchResults = await ProductVariant.aggregate([
      {
        $lookup: {
          from: "products",
          localField: "productId",
          foreignField: "_id",
          as: "productInfo",
        },
      },
      {
        $unwind: "$productInfo",
      },
      {
        $match: {
          $or: [
            { "productInfo.name": { $regex: regexPattern, $options: "i" } },
            {
              "productInfo.shortDescription": {
                $regex: regexPattern,
                $options: "i",
              },
            },
            {
              "productInfo.description": {
                $regex: regexPattern,
                $options: "i",
              },
            },
            { "color.colorName": { $regex: regexPattern, $options: "i" } },
            { "color.baseColor": { $regex: regexPattern, $options: "i" } },
            { sku: { $regex: regexPattern, $options: "i" } },
            { "attributes.attribute": { $regex: regexPattern, $options: "i" } },
            { "attributes.value": { $regex: regexPattern, $options: "i" } },
          ],
          status: true, // Ch·ªâ l·∫•y s·∫£n ph·∫©m active
        },
      },
      {
        $addFields: {
          // T√≠nh gi√° nh·ªè nh·∫•t c·ªßa variant
          minPrice: { $min: "$sizes.price" },
          maxPrice: { $max: "$sizes.price" },
          totalStock: { $sum: "$sizes.stock" },
          hasStock: { $gt: [{ $sum: "$sizes.stock" }, 0] },
        },
      },
      {
        $match: {
          hasStock: true, // Ch·ªâ l·∫•y s·∫£n ph·∫©m c√≤n h√†ng
        },
      },
      {
        $project: {
          _id: 1,
          productId: {
            _id: "$productInfo._id",
            name: "$productInfo.name",
            shortDescription: "$productInfo.shortDescription",
            categoryId: "$productInfo.categoryId",
          },
          color: 1,
          images: 1,
          sizes: 1,
          attributes: 1,
          sku: 1,
          minPrice: 1,
          maxPrice: 1,
          totalStock: 1,
          price: "$minPrice", // S·ª≠ d·ª•ng gi√° nh·ªè nh·∫•t ƒë·ªÉ hi·ªÉn th·ªã
          relevanceScore: {
            $add: [
              // ƒêi·ªÉm cao cho t√™n s·∫£n ph·∫©m
              {
                $cond: {
                  if: {
                    $regexMatch: {
                      input: "$productInfo.name",
                      regex: regexPattern,
                      options: "i",
                    },
                  },
                  then: 15,
                  else: 0,
                },
              },
              // ƒêi·ªÉm cho attributes
              {
                $cond: {
                  if: {
                    $gt: [
                      {
                        $size: {
                          $filter: {
                            input: "$attributes",
                            cond: {
                              $or: [
                                {
                                  $regexMatch: {
                                    input: "$$this.attribute",
                                    regex: regexPattern,
                                    options: "i",
                                  },
                                },
                                {
                                  $regexMatch: {
                                    input: "$$this.value",
                                    regex: regexPattern,
                                    options: "i",
                                  },
                                },
                              ],
                            },
                          },
                        },
                      },
                      0,
                    ],
                  },
                  then: 12,
                  else: 0,
                },
              },
              // ƒêi·ªÉm cho SKU (exact match cao h∆°n)
              {
                $cond: {
                  if: {
                    $regexMatch: {
                      input: "$sku",
                      regex: regexPattern,
                      options: "i",
                    },
                  },
                  then: 10,
                  else: 0,
                },
              },
              // ƒêi·ªÉm cho m√†u s·∫Øc
              {
                $cond: {
                  if: {
                    $or: [
                      {
                        $regexMatch: {
                          input: "$color.colorName",
                          regex: regexPattern,
                          options: "i",
                        },
                      },
                      {
                        $regexMatch: {
                          input: "$color.baseColor",
                          regex: regexPattern,
                          options: "i",
                        },
                      },
                    ],
                  },
                  then: 8,
                  else: 0,
                },
              },
              // ƒêi·ªÉm cho m√¥ t·∫£
              {
                $cond: {
                  if: {
                    $or: [
                      {
                        $regexMatch: {
                          input: "$productInfo.shortDescription",
                          regex: regexPattern,
                          options: "i",
                        },
                      },
                      {
                        $regexMatch: {
                          input: "$productInfo.description",
                          regex: regexPattern,
                          options: "i",
                        },
                      },
                    ],
                  },
                  then: 5,
                  else: 0,
                },
              },
              // Bonus cho s·∫£n ph·∫©m c√≥ nhi·ªÅu stock
              {
                $cond: {
                  if: { $gt: ["$totalStock", 10] },
                  then: 2,
                  else: 0,
                },
              },
            ],
          },
        },
      },
      {
        $sort: {
          relevanceScore: -1,
          totalStock: -1, // ∆Øu ti√™n s·∫£n ph·∫©m c√≥ nhi·ªÅu h√†ng
          minPrice: 1,
        },
      },
      {
        $limit: 8,
      },
    ]);

    console.log(`üìä Text search found: ${textSearchResults.length} results`);

    if (textSearchResults.length >= 5) {
      // N·∫øu ƒë√£ c√≥ ƒë·ªß k·∫øt qu·∫£ t·ª´ text search, tr·∫£ v·ªÅ lu√¥n
      return res.json({
        success: true,
        suggestions: textSearchResults.slice(0, 5),
        method: "text_search",
        debug: {
          query: searchQuery,
          expandedQueries: expandedQueries,
          textResults: textSearchResults.length,
        },
      });
    }

    // 2. N·∫øu text search kh√¥ng ƒë·ªß, th√™m semantic search
    try {
      console.log("ü§ñ Running semantic search...");
      const embeddingResult = await embeddingModel.embedContent(searchQuery);
      const queryEmbedding = embeddingResult.embedding.values;

      const semanticResults = await ProductVariant.aggregate([
        {
          $match: {
            embedding: { $exists: true, $ne: null, $not: { $size: 0 } },
            status: true,
          },
        },
        {
          $lookup: {
            from: "products",
            localField: "productId",
            foreignField: "_id",
            as: "productInfo",
          },
        },
        {
          $unwind: "$productInfo",
        },
        {
          $addFields: {
            similarity: {
              $let: {
                vars: {
                  dotProduct: {
                    $reduce: {
                      input: {
                        $range: [
                          0,
                          {
                            $min: [
                              { $size: "$embedding" },
                              queryEmbedding.length,
                            ],
                          },
                        ],
                      },
                      initialValue: 0,
                      in: {
                        $add: [
                          "$$value",
                          {
                            $multiply: [
                              { $arrayElemAt: ["$embedding", "$$this"] },
                              { $arrayElemAt: [queryEmbedding, "$$this"] },
                            ],
                          },
                        ],
                      },
                    },
                  },
                },
                in: "$$dotProduct",
              },
            },
            minPrice: { $min: "$sizes.price" },
            hasStock: { $gt: [{ $sum: "$sizes.stock" }, 0] },
          },
        },
        {
          $match: {
            similarity: { $gte: CONFIG.SIMILARITY_THRESHOLD },
            hasStock: true,
          },
        },
        {
          $project: {
            _id: 1,
            productId: {
              _id: "$productInfo._id",
              name: "$productInfo.name",
              shortDescription: "$productInfo.shortDescription",
              categoryId: "$productInfo.categoryId",
            },
            color: 1,
            images: 1,
            sizes: 1,
            sku: 1,
            price: "$minPrice",
            similarity: 1,
          },
        },
        { $sort: { similarity: -1 } },
        { $limit: 8 },
      ]);

      console.log(
        `üéØ Semantic search found: ${semanticResults.length} results`
      );

      // K·∫øt h·ª£p k·∫øt qu·∫£ v√† lo·∫°i b·ªè tr√πng l·∫∑p
      const combinedResults = [...textSearchResults];
      const existingIds = new Set(
        textSearchResults.map((item) => item._id.toString())
      );

      for (const semanticResult of semanticResults) {
        if (
          !existingIds.has(semanticResult._id.toString()) &&
          combinedResults.length < 5
        ) {
          combinedResults.push(semanticResult);
        }
      }

      res.json({
        success: true,
        suggestions: combinedResults.slice(0, 5),
        method: "combined_search",
        debug: {
          query: searchQuery,
          textResults: textSearchResults.length,
          semanticResults: semanticResults.length,
          combinedResults: combinedResults.length,
        },
      });
    } catch (embeddingError) {
      // Fallback v·ªÅ text search n·∫øu c√≥ l·ªói embedding
      console.log(
        "‚ùå Embedding error, fallback to text search:",
        embeddingError.message
      );

      res.json({
        success: true,
        suggestions: textSearchResults.slice(0, 5),
        method: "text_search_fallback",
        debug: {
          query: searchQuery,
          error: embeddingError.message,
          textResults: textSearchResults.length,
        },
      });
    }
  } catch (error) {
    console.error("üí• Search suggestions error:", error);
    res.status(500).json({
      success: false,
      message: "L·ªói t√¨m ki·∫øm g·ª£i √Ω",
      error: error.message,
    });
  }
};
